
### Конспект українською мовою

#### Основи дизайну API

- **Якість дизайну API**:
    
    - Важливість врахування архітектури, проектування класів та окремих функціональних викликів.
    - Дизайн повинен забезпечувати зручність для користувачів і відповідати їхнім потребам.
    - Визначення функціональних вимог є ключовим перед створенням API.
- **Методологія**:
    
    - Аналіз проблеми → створення початкового дизайну → реалізація рішення.
    - Це ітеративний процес: нові вимоги або помилки можуть призводити до перегляду дизайну.

#### Аналіз як частина дизайну

1. **Вимоги**: описують, що саме має робити API.
2. **Сценарії використання**: ілюструють поведінку API з точки зору користувача.
3. **Юзер сторі**: деталізують окремі аспекти роботи API.

#### Технічний борг

- **Що це таке**:
    
    - Код низької якості, який створений під тиском часу або ресурсів.
    - Проблема може зростати через недостатню увагу до довгострокової підтримки коду.
- **Види технічного боргу**:
    
    - **Ненавмисний**: викликаний помилками чи недосвідченістю розробників.
    - **Навмисний**: свідоме скорочення витрат на користь швидкого результату.
- **Ризики**:
    
    - **Хрупкість**: зміни в одній частині коду можуть викликати непередбачувані помилки в інших.
    - **Жорсткість**: труднощі зі внесенням навіть незначних змін.
    - **Немобільність**: код складно адаптувати або використовувати повторно.
    - **Непереносимість**: розуміння коду обмежене кількома розробниками.

#### Наслідки поганого дизайну

- Збільшення залежностей між компонентами.
- Утворення "спагетті-коду" або "великої купи бруду".
- Зростання витрат на підтримку та розвиток проєкту.

### Висновок

Хороший дизайн API — це процес, що вимагає аналізу, чіткого планування та врахування майбутньої підтримки. Зосередження на якісних рішеннях на ранніх етапах допоможе уникнути технічного боргу та складнощів у майбутньому.

Ознаки того, що код досягає критичної точки (згідно з текстом):

### 1. **Хрупкість (Fragility)**:

- **Що це означає**: Код стає вразливим до несподіваних побічних ефектів. Зміни в одній частині програми можуть викликати помилки в інших, зовсім не пов'язаних місцях.
- **Чому це небезпечно**: Розробники бояться вносити зміни через ризик зламати щось інше. Код стає важким у підтримці.

### 2. **Жорсткість (Rigidity)**:

- **Що це означає**: Код важко змінювати. Навіть незначні зміни вимагають значних зусиль, часто включаючи складне та ризиковане рефакторинг.
- **Чому це небезпечно**: Зміни у проєкті уповільнюються, і внесення нових функцій або виправлення багів стає тривалим процесом.

### 3. **Немобільність (Immobility)**:

- **Що це означає**: Код не можна легко використовувати повторно в інших частинах системи чи в нових проєктах. Зазвичай це виникає через надмірну інтеграцію з іншими компонентами.
- **Чому це небезпечно**: Неможливість адаптації чи повторного використання коду призводить до дублювання та додаткових витрат часу.

### 4. **Непереносимість (Nontransferability)**:

- **Що це означає**: Лише обмежене коло інженерів розуміє, як працює код. Зазвичай це люди, які його написали, або ті, хто намагався його виправити.
- **Чому це небезпечно**: Якщо ключові розробники покидають проєкт, нові учасники не можуть ефективно працювати з кодом. Це створює "вузьке місце" в команді.

### Висновок

Ці ознаки вказують на критичну точку, після якої підтримка коду стає значно дорожчою та складнішою. Вчасне виявлення цих проблем дозволяє вжити заходів для рефакторингу або перебудови системи.


#### **Виплата технічного боргу**

- **Ситуація**: З часом накопичення технічного боргу доходить до критичної точки, коли компанія витрачає більше часу на підтримку старого коду, ніж на додавання нових функцій.
- **Результат**: Для вирішення проблем часто запускається "проект наступного покоління", який передбачає суттєві зміни або повну переробку старої системи.

#### **Підходи до реорганізації коду**

1. **Еволюція**:
    
    - **Опис**: Інтеграція нових вимог із поступовим рефакторингом існуючої системи.
    - **Переваги**: Збереження функціональної системи, яка може працювати під час змін.
    - **Недоліки**: Робота в рамках старого дизайну, що може бути не оптимальним.
    - **Рішення**: Використання обгорток для створення більш чистих API.
2. **Революція**:
    
    - **Опис**: Повне переписування системи з нуля.
    - **Переваги**: Можливість використати весь досвід і сучасні технології.
    - **Недоліки**: Великі витрати часу, ресурсів, ризик надмірного ускладнення системи.

#### **Виклики під час переходу**

- Управління командами, які працюють над старими та новими системами.
- Вплив на структуру компанії (реорганізація, скорочення).
- Необхідність зберігати баланс між поточними вимогами та довгостроковими цілями.

#### **Інвестування у довгостроковий дизайн**

1. **Ціна технічного боргу**:
    
    - Наприклад, проект для заміни "зношеної" бази коду може коштувати мільйони доларів через зарплати та витрати на менеджмент.
2. **Причини проблем**:
    
    - Відсутність якісного дизайну з самого початку.
    - Невігластво інженерів щодо принципів дизайну.
    - Створення коду без довгострокових цілей (прототипи, тимчасові рішення).
    - Непрозорі процеси, які ховають технічний борг.
    - Поступова деградація добре спроєктованих систем через неконтрольовані зміни.
3. **Рекомендації**:
    
    - Зберігати чітку концептуальну цілісність системи.
    - Не відкладати рефакторинг на потім.
    - Забезпечувати покриття тестами, щоб уникнути регресій.

#### **Цінність якісного дизайну**

- Інвестування в якісний дизайн дозволяє уникнути технічного боргу, зберігати модульність і забезпечувати легкість змін.
- Окремий акцент на важливості відокремлення інтерфейсу від реалізації для підтримуваності коду.
- **Рекомендація**: підтримувати високу планку дизайну API, регулярно рефакторити код і контролювати зміни.

#### **Основний висновок**

- Вибір між "еволюцією" та "революцією" має базуватися на доступних ресурсах, складності системи та довгострокових цілях. Незалежно від вибору, якісний дизайн та стратегічне планування мають бути пріоритетом.
  
  
### 8 сценаріїв проблемного дизайну

#### 1. **Відсутність початкового якісного дизайну**

- **Опис**: Компанія не створює якісний дизайн на етапі початкової розробки через переконання, що це дорого та неефективно.
- **Результат**: У майбутньому доводиться витрачати набагато більше ресурсів на виправлення помилок і підтримку.

#### 2. **Незнання принципів якісного дизайну**

- **Опис**: Інженери або не знайомі з методами якісного дизайну, або вважають їх недоречними для свого проєкту.
- **Результат**: Дизайн коду не відповідає стандартам якості, що призводить до накопичення технічного боргу.

#### 3. **Код, створений для короткострокового використання**

- **Опис**: Код спочатку планувався як тимчасовий (наприклад, прототип), але в результаті був інтегрований у основну систему.
- **Результат**: Код, який не призначений для довготривалого використання, стає основою системи, що ускладнює її підтримку.

#### 4. **Непрозорий процес розробки**

- **Опис**: Технічний борг не фіксується і не відстежується, тому окремі частини системи забуваються або залишаються невирішеними.
- **Результат**: Відсутність контролю призводить до нагромадження проблем, які з часом стають критичними.

#### 5. **Погіршення добре спроєктованої системи**

- **Опис**: Спочатку якісний дизайн деградує через неконтрольоване зростання або внесення поганих змін.
- **Результат**: Система втрачає концептуальну цілісність і стає складною у використанні та підтримці.

#### 6. **Відкладання змін через нові вимоги**

- **Опис**: Нові вимоги потребують змін у дизайні, але компанія постійно відкладає цей процес на користь швидких рішень.
- **Результат**: Відкладання рефакторингу призводить до накопичення технічного боргу.

#### 7. **Довготривалі баги**

- **Опис**: Помилки залишаються невиправленими тривалий час, через що система стає менш надійною.
- **Результат**: Постійне додавання функціональності без уваги до якості призводить до регресій і зниження стабільності.

#### 8. **Відсутність тестів**

- **Опис**: Система не має автоматизованих тестів, через що помилки часто з’являються при внесенні змін.
- **Результат**: Розробники бояться змінювати код, оскільки це може призвести до непередбачуваних наслідків.

### Висновок

Ці сценарії підкреслюють важливість якісного дизайну на ранніх етапах розробки. Рішення проблем, описаних у цих сценаріях, включає створення якісного початкового дизайну, регулярний рефакторинг та впровадження тестів. ​

### Основи збору та підтримки вимог

#### **Збір функціональних вимог**

- **Мета**: Розуміння того, що має робити система, щоб уникнути витрат часу та ресурсів на створення невідповідного рішення.
- **Типи вимог**:
    1. **Бізнес-вимоги**: Описують цінність програмного забезпечення для бізнесу (як воно відповідає потребам організації).
    2. **Функціональні вимоги**: Визначають поведінку системи (що саме вона повинна виконувати).
    3. **Нефункціональні вимоги**: Визначають якісні характеристики системи (наприклад, продуктивність, масштабованість).

#### **Функціональні вимоги**

- Визначають очікувану функціональність API.
- Формуються у співпраці з користувачами API, які також можуть бути розробниками.
- Питання для користувачів:
    - Які завдання вони хочуть вирішувати за допомогою API?
    - Який оптимальний робочий процес з їхньої точки зору?
    - Які вхідні та вихідні дані повинні підтримуватися?
    - Які формати або протоколи мають бути сумісними?

#### **Приклад функціональних вимог (ATM)**

- **REQ 1.1**: Система повинна припиняти взаємодію, якщо немає зв'язку з банком або закінчилися гроші.
- **REQ 1.2**: Перевірка валідності вставленої картки.
- **REQ 1.3**: Перевірка правильності введеного PIN-коду.
- **REQ 1.4**: Видача запрошеної суми та зняття грошей з рахунку.
- **REQ 1.5**: Сповіщення користувача у разі неможливості завершення транзакції.

#### **Нефункціональні вимоги**

- Характеризують, як система виконує свої функції.
- Приклади:
    - **Продуктивність**: Обмеження швидкості операцій.
    - **Сумісність платформ**: На яких платформах працює код.
    - **Безпека**: Захист даних і конфіденційність.
    - **Масштабованість**: Підтримка великих обсягів даних.
    - **Зручність використання**: Простота навчання і використання.

#### **Підтримка вимог**

- Вимоги змінюються протягом проєкту, тому необхідно зберігати їх версії та дати.
- У середньому 25% функціональних вимог змінюються під час розробки, що може впливати на 70-85% коду.
- Зміна вимог повинна супроводжуватися переглядом графіка та бюджету проєкту.
- **Запобігання проблемам**:
    - Не дозволяти "розповзання вимог" (необґрунтоване додавання нових вимог).
    - Оцінювати нові вимоги з точки зору їх цінності для бізнесу.

### Висновок

Якісний збір і підтримка вимог дозволяє уникнути дорогих змін і забезпечити довгостроковий успіх програмного забезпечення. Збалансоване врахування бізнесових, функціональних і нефункціональних вимог є ключем до створення ефективного API.




