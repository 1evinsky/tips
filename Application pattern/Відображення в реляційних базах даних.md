
**Основна роль шару джерел даних**:

- Забезпечення комунікації з різними елементами інфраструктури, необхідними для функціонування додатка.

**Взаємодія з базами даних**:

- Переважна більшість сучасних систем взаємодіє з реляційними базами даних.
- Хоча існує багато даних у старих форматах зберігання (наприклад, ISAM та VSAM на магнітних машинах), основна увага сьогодні зосереджена на реляційних базах даних.

**Причини успіху реляційних баз даних**:

- Важливим чинником є наявність SQL — стандартної мови для комунікації з базами даних.
- Хоча SQL має свої недоліки та специфічні розширення в різних постачальників, його основний синтаксис залишається зрозумілим та загальновживаним.

# Архітектурні патерни

**Архітектурні патерни**:

- Визначають, як доменна логіка взаємодіє з базою даних.
- Вибір архітектурного патерну впливає на загальний дизайн системи і важко підлягає рефакторингу.

**Виклики використання SQL**:

- Незважаючи на поширене використання SQL, багато розробників не володіють ним на достатньому рівні.
- Це призводить до труднощів у формулюванні ефективних запитів.
- Краще використовувати механізми доступу до даних, які відповідають мові програмування додатка.
- Адміністратори баз даних (DBA) також потребують доступу до SQL для оптимізації запитів і налаштування індексів.

**Рекомендації щодо організації коду**:

- Розділити доступ до SQL та доменну логіку, помістивши SQL в окремі класи.
- Структурувати ці класи відповідно до таблиць бази даних, створивши по одному класу для кожної таблиці.
- Ці класи формують "Gateway" до таблиць, дозволяючи решті програми не знати про SQL.

**Типи Gateway**:

1. **Row Data Gateway**:
    
    - Один екземпляр для кожного рядка, повернутого запитом.
    - Відповідає об'єктно-орієнтованому підходу до даних.
2. **Table Data Gateway**:
    
    - Використовує загальну структуру даних — Record Set, яка відображає табличну природу бази даних.
    - Необхіден лише один клас для кожної таблиці, що забезпечує методи для запитів до бази даних і повертає Record Set.

![[Figure 3.1.png]]

![[Figure 3.2.png]]

**Використання патернів Gateway**:

- Навіть у простих додатках рекомендується використовувати патерни Gateway для чіткого розділення SQL та доменної логіки.
- **Table Data Gateway** добре поєднується з **Record Set**, що робить його очевидним вибором при використанні **Table Module**.

**Stored Procedures**:

- Дизайнери часто віддають перевагу доступу до бази даних через збережені процедури.
- Рекомендується створити **Table Data Gateway** для обгортання викликів до збережених процедур, щоб інкапсулювати механіку викликів.

**Використання з Domain Model**:

- Можливо використовувати як **Row Data Gateway**, так і **Table Data Gateway** з **Domain Model**.
- У простих додатках, де доменна структура відповідає структурі бази даних, доцільно використовувати **Active Record**:
    - Один клас домену на таблицю бази даних, з відповідальною бізнес-логікою.

**Складні додатки**:

- При ускладненні доменної логіки простий підхід Active Record стає недостатнім:
    - Відсутність однозначного відповідності між класами домену та таблицями ускладнює використання.
- Для тестування складної логіки без постійного доступу до бази даних необхідно більше абстракції.

**Висновки**:

- Збагачення **Domain Model** вимагає додаткової абстракції, такої як **Gateway**.
- Проте це веде до зв’язку між доменною моделлю та схемою бази даних, ускладнюючи трансформацію полів між **Gateway** та доменними об'єктами.

![[Figure 3.3.png]]

**Ізоляція Domain Model**:

- Рекомендується повністю ізолювати **Domain Model** від бази даних за допомогою **Data Mapper** (165).
- **Data Mapper** відповідає за завантаження та збереження даних між базою даних і доменною моделлю, що дозволяє їм розвиватися незалежно.

**Вибір механізму збереження**:

- Не рекомендується використовувати **Gateway** (466) як основний механізм збереження для **Domain Model**.
- Для простих доменів з близькою відповідністю між класами та таблицями слід використовувати **Active Record** (160).
- Для складніших доменів підходить **Data Mapper** (165).

**Комбінування патернів**:

- Патерни не є взаємовиключними; кожен з них можна використовувати в залежності від потреб.
- Важливо вибрати один основний механізм збереження, щоб уникнути плутанини.
- Можливо використовувати **Gateway** для обгортання таблиць або сервісів, що функціонують як зовнішні інтерфейси.

**Терміни та їх застосування**:

- У дискусії часто вживається термін "таблиця", але більшість технік також застосовуються до **views**, запитів, інкапсульованих через збережені процедури.
- "Таблиця" представляє собою табличну структуру даних, а **views** можна розглядати як віртуальні таблиці, оскільки SQL працює з ними подібно до звичайних таблиць.


![[Figure 3.4.png]]

**Об'єктно-орієнтовані бази даних (ООБД)**:

- ООБД вирішують проблему "імпедансної несумісності" між об'єктами та реляційними структурами.
- Вони дозволяють працювати з великими структурами взаємопов'язаних об'єктів без потреби в картографуванні.
- Діють як прозора система транзакцій, що забезпечує зберігання даних на дисках.

**Переваги ООБД**:

- Підвищують продуктивність програмістів, зменшуючи витрати на картографування до реляційних баз.
- Витрати на картографування можуть становити близько третини програмістського зусилля.

**Недоліки ООБД**:

- Основна проблема — ризик. Реляційні бази даних є зрозумілою та перевіреною технологією з підтримкою великих постачальників.
- SQL забезпечує стандартний інтерфейс для різних інструментів.

**Інструменти O/R картографування**:

- Навіть якщо ООБД недоступні, варто розглянути придбання інструментів O/R картографування для **Domain Model**.
- Комерційні інструменти значно розвинутіші за те, що можна зробити вручну, попри їхню вартість.

**Тенденції на ринку**:

- З'являються рішення, які намагаються надати OO-доступ до реляційних баз, наприклад, JDO у Java, але їхня ефективність ще не зрозуміла.

**Рекомендації**:

- Незалежно від того, чи купуєте ви інструмент, важливо знати про патерни картографування.
- Хороші O/R інструменти надають безліч варіантів, але їх використання і налаштування потребує зусиль.
# Конспект: Проблеми поведінки в O/R відображенні

#### Основні питання

- При обговоренні O/R відображення акцент часто ставиться на структурних аспектах, але важливі також архітектурні та поведінкові питання.
- Основна проблема — це управління завантаженням і збереженням об'єктів у базі даних.

#### Проблема поведінки

- Об'єкти (наприклад, клієнти) можуть мати методи `load` та `save`, але управління цими операціями стає складним, коли потрібно відслідковувати модифікації кількох об'єктів.
- Існує ризик непослідовності даних, якщо об'єкти змінюються без належного контролю.

#### Проблеми з конкурентністю

- Під час читання та модифікації об'єктів важливо зберігати консистентність стану бази даних, щоб уникнути змін від інших процесів.

#### Паттерн "Unit of Work"

- Паттерн "Unit of Work" дозволяє зібрати всі операції з об'єктами в одному місці:
    - Відстежує всі прочитані та модифіковані об'єкти.
    - Здійснює всі зміни в базі даних через один метод `commit`, що спрощує управління складними транзакціями.

#### Ідентифікаційна карта (Identity Map)

- Зберігає посилання на вже завантажені об'єкти, щоб уникнути дублювання в пам'яті.
- Якщо об'єкт вже завантажений, повертається посилання на існуючий екземпляр, що забезпечує коректність ідентичностей.

#### Ліниве завантаження (Lazy Load)

- Дозволяє завантажувати пов'язані об'єкти лише за потреби, зменшуючи витрати на пам'ять і зберігаючи ефективність запитів.
- Використовує плейсхолдери, які завантажують реальні об'єкти з бази даних тільки при спробі доступу до них.

#### Висновок

- Впровадження паттернів "Unit of Work", "Identity Map" та "Lazy Load" допомагає ефективно вирішувати проблеми поведінки в O/R відображенні, забезпечуючи консистентність даних і оптимізуючи взаємодію з базою даних.