
# Організація бізнес-логіки

Є три базові шаблони для організації бізнес-логіки: : *Transaction Script*, *Domain Model*, і *Table Module*

## Transaction Script

**Transaction Script**  — це простий підхід до зберігання бізнес-логіки. Це по суті процедура, яка:

1. Отримує вхідні дані з презентаційного шару.
2. Обробляє ці дані, включаючи валідацію та обчислення.
3. Зберігає дані в базу даних.
4. Виконує операції з іншими системами.
5. Відповідає з новими даними для презентаційного шару, можливо, виконавши додаткові обчислення для організації та форматування відповіді.

**Основні характеристики:**

- Організовано як окрема процедура для кожної дії, яку може виконати користувач.
- Може містити підпрограми, які можуть бути спільно використані між різними *Transaction Script*.
- Наприклад, у системі роздрібної торгівлі можуть бути скрипти для завершення покупки, додавання товару до кошика, перегляду статусу доставки тощо.

**Переваги:**

- Простота: Легко зрозуміла для більшості розробників.
- Добре інтегрується з простим рівнем доступу до даних, таким як *Row Data Gateway* або *Table Data Gateway*.
- Ясно, як встановити межі транзакції: початок і кінець транзакції зрозумілі й легкі для автоматизації інструментами.

**Недоліки:**

- При збільшенні складності бізнес-логіки можуть виникати проблеми з повторенням коду, оскільки кілька транзакцій можуть виконувати схожі дії.
- Частину дублювання можна усунути шляхом виділення загальних підпрограм, але деякі повторення важко виявити та усунути.
- Результуючий додаток може стати заплутаною мережею процедур без чіткої структури.

## Domain Model

**Domain Model** — це об'єктноорієнтований підхід до обробки складної бізнес-логіки. Основна ідея цього підходу полягає в створенні моделі домену, яка організована навколо імен (суб'єктів) у домені.

**Основні характеристики:**

- **Модель домену**: У моделі домену створюються класи, що відповідають основним об'єктам у системі. Наприклад, у системі оренди можуть бути класи для об'єктів «оренда», «актив» і т.д.
- **Логіка всередині об'єктів**: Логіка для валідації і обчислень розміщується всередині цих класів. Наприклад, об'єкт «відправка» може містити метод для обчислення вартості доставки.
- **Делегування логіки**: Процедури, що виконують обчислення або інші дії, делегуються відповідним методам класів моделі домену.

**Переваги:**

- **Організація логіки**: Логіка розподіляється між об'єктами відповідно до їхніх функцій і відповідальностей. Кожен об'єкт обробляє частину логіки, що стосується саме його.
- **Орієнтація на об'єкти**: Це підхід, який відрізняється від *Transaction Script*, де вся логіка для дії користувача зосереджена в одній процедурі.

**Недоліки:**

- **Складність навчання**: Для новачків може бути важко звикнути до *Domain Model*, оскільки потрібно розуміти, де саме знаходиться необхідна поведінка в розподілі між об'єктами.
- **Можливість плутанини**: Може бути складно знайти, де конкретно реалізовано певну частину логіки, особливо на початкових етапах роботи з моделлю.

## Порівняння між Transaction Script та Domain Model

- **Transaction Script**: Логіка зосереджена в одній процедурі, що може призвести до дублювання коду і ускладнень у підтримці.
- **Domain Model**: Логіка розподілена між об'єктами, що може зменшити дублювання і спростити підтримку, але потребує розуміння структури моделі домену.

Для кращого розуміння різниці між цими підходами можна переглянути діаграми послідовностей для обох методів. Наприклад, для розрахунку доходів від контракту необхідно визначити тип продукту, застосувати відповідний алгоритм і створити об'єкти для відображення результатів обчислень.


![[Pasted image 20240916152741.png]]

**Transaction Script:

- **Метод**: Виконує всю логіку самостійно. Об'єкти даних лише передають інформацію до скрипту.
- **Об'єкти**: Зазвичай є *Table Data Gateways*, які просто передають дані.

**Domain Model**:

- **Множинні об'єкти**: Розподіляють поведінку між собою. Наприклад, різні об'єкти можуть делегувати частини логіки один одному, поки стратегічний об'єкт не створює результати.
- **Гнучкість**: Легше впоратися зі складною логікою, додаючи нові стратегії або алгоритми (наприклад, для розрахунку визнання доходів) без збільшення умов у коді.

**Переваги Domain Model**:

- **Організація логіки**: Після освоєння моделі можна краще управляти складною логікою.
- **Модульність**: Легше додавати нові стратегії і алгоритми без переписування існуючих скриптів.
- **Перевага для досвідчених розробників**: Як тільки звикаєш до об'єктної моделі, вона стає зручною і навіть у простих випадках може бути кращою.

**Недоліки Domain Model**:

- **Складність освоєння**: Новації в об'єктних моделях можуть бути складними для новачків. Розробникам може знадобитися час для адаптації.
- **Складність відповідності з базою даних**: Зі збільшенням складності моделі зростає складність її відображення в реляційній базі даних. Потрібно буде використовувати *Data Mapper* для картування.

**Висновок**:

- **Вартість**: Розробка та підтримка багатої об'єктної моделі може бути дорогою і вимагати значних зусиль на початкових етапах.
- **Довгострокові переваги**: Коли звикаєш до *Domain Model*, вона стає легкою у використанні, і це формує певний підхід у розробці.

Таким чином, хоча *Domain Model* може бути складнішою в освоєнні і реалізації, її гнучкість і організованість у довгостроковій перспективі часто роблять її більш привабливою для роботи з складною бізнес-логікою.

## Table Module

**Table Module** — це підхід до структурування бізнес-логіки, який можна розглядати як проміжний варіант між *Transaction Script* та *Domain Model*.

**Основні характеристики Table Module:**

- **Інстанси**: На відміну від *Domain Model*, де є окремий екземпляр для кожного запису в базі даних, *Table Module*  має лише один екземпляр для всіх записів таблиці.
- **Record Set**:  *Table Module* працює з *Record Set*, що є результатом SQL-запитів до бази даних. Клієнт запитує дані, формує *Record Set* і передає його в *Table Module* як аргумент.
- **Операції**: Після отримання *Record Set*, клієнт може викликати методи *Table Module* для виконання різних операцій. Для обробки конкретного запису необхідно передати ідентифікатор запису (ID).

**Переваги Table Module:**

- **Структурованість**: Підхід організовує бізнес-логіку навколо таблиць, що забезпечує більшу структуру порівняно з *Transaction Script*  і полегшує виявлення і усунення дублювань.
- **Інтеграція з GUI**: Оскільки багато GUI-систем працюють з результатами SQL-запитів, **Table Module**  добре інтегрується з такими системами. Дані можуть бути запитані, оброблені в *Table Module*, а потім передані для відображення в GUI.
- **Валідація та обчислення**: *Table Module* може також використовуватися для подальших перевірок і обчислень після маніпуляцій з даними.

**Недоліки Table Module:**

- **Менш гнучкий**: Не підтримує деякі техніки, характерні для *Domain Model*, такі як спадкування, стратегії і інші об'єктно-орієнтовані патерни, які дозволяють тоншу структуризацію логіки.

**Висновок:**

- **Проміжний варіант**:  *Table Module* знаходиться між *Transaction Scrip* і *Domain Model*. Він забезпечує більше структури, ніж Transaction Script, але не має всієї гнучкості *Domain Model*.
- **Платформи**: Багато платформ, особливо Microsoft COM і .NET, використовують цей стиль розробки завдяки його сумісності з *Record Set* і GUI-системами.

# Як вибрати?

**Вибір паттерна для бізнес-логіки**: Вибір між _Transaction Script_, _Domain Model_ та _Table Module_ залежить від складності вашої бізнес-логіки.

**Основні моменти для вибору:**

1. **Простота логіки**:
    
    - **Domain Model**: Менш привабливий при простій бізнес-логіці через високі початкові витрати на освоєння та складність роботи з джерелом даних. Витрати на розробку можуть бути не виправдані.
    - **Transaction Script**: Простий і зрозумілий для реалізації, але може стати важким у підтримці при збільшенні складності.
2. **Зростання складності**:
    
    - **Domain Model**: Стає більш привабливим при зростанні складності бізнес-логіки. Вона краще справляється з розширенням функціональності завдяки структурованості і можливостям ООП.
    - **Transaction Script** і _Table Module_: Можуть досягти межі зростання складності, що призводить до експоненційних труднощів у додаванні нових функцій.
3. **Фактори, що впливають на вибір**:
    
    - **Досвід команди**: Команда, знайома з _Domain Model_, зможе знизити початкові витрати на впровадження цього паттерна, хоча витрати на складність джерела даних залишаються.
    - **Підтримка _Record Set_**: Якщо ваше середовище, таке як .NET або Visual Studio, підтримує _Record Set_, то _Table Module_ буде привабливим. Якщо ж підтримки немає, використання _Table Module_ може бути недоцільним.
4. **Гнучкість вибору**:
    
    - Якщо ви почали з *Transaction Script* і зрозуміли, що вам потрібна більш складна бізнес-логіка, не бійтеся рефакторити в _Domain Model_.
    - Якщо ви почали з _Domain Model_ і вирішили, що вам потрібен простіший підхід, перехід до *Transaction Script* зазвичай є менш вигідним, якщо тільки не вдалося спростити джерело даних.
5. **Комбінування паттернів**:
    
    - Часто використовують *Transaction Script* для частини бізнес-логіки, а _Table Module_ або _Domain Model_ для інших частин системи.

**Висновок**: Підходьте до вибору паттерна з урахуванням складності вашої бізнес-логіки, досвіду команди та наявності інструментів для підтримки _Record Set_. Ваше рішення може змінюватися в залежності від розвитку проекту і його вимог.

# Service Layer

**Service Layer** — це підхід до структурування бізнес-логіки, який передбачає розділення доменного шару на два рівні. Service Layer розташовується над нижнім рівнем, яким може бути _Domain Model_ або _Table Module_.

**Основні функції Service Layer:**

- **API**: Service Layer виступає як API для додатку, через який взаємодіють презентаційна логіка і доменний шар.
- **Транзакції та безпека**: Тут можна розмістити контроль транзакцій і перевірки безпеки. Зазвичай описуються властивості транзакцій і безпеки для кожного методу. Це може бути реалізовано через окремі файли властивостей або атрибути в коді.

**Рівні реалізації Service Layer:**

1. **Мінімальний випадок**:
    
    - Service Layer функціонує як фасад, який просто переадресовує виклики до нижчих рівнів. Реальна бізнес-логіка залишається в нижніх об'єктах. Це спрощує використання API і робить легшим додавання транзакційних обгорток і перевірок безпеки.
2. **Бізнес-логіка в Service Layer**:
    
    - Вся бізнес-логіка розміщується в Service Layer. Нижчі доменні об'єкти залишаються дуже простими, і, якщо це _Domain Model_, він буде мати пряме відображення в базі даних, що дозволяє використовувати простіші шари джерела даних, такі як _Active Record_.
3. **Контролер-сутність (controller-entity)**:
    
    - Комбінація логіки: логіка, специфічна для конкретної транзакції або випадку використання, розміщується в _Transaction Scripts_, які називають контролерами або сервісами. Логіка, що використовується в кількох випадках, залишається в доменних об'єктах, які називаються сутностями.

**Персональна перевага**:

- Автор надає перевагу мати найтонший Service Layer, якщо він взагалі потрібен. Найчастіше підходить відмовитись від Service Layer і додати його лише в разі потреби. Проте, деякі дизайнери вважають за краще використовувати багатий Service Layer, і це може бути успішним підходом.

**Висновок**:

- Вибір використовувати Service Layer залежить від складності вашої бізнес-логіки і вимог додатку. Хоча Service Layer може бути корисним, рішення про його використання слід приймати з урахуванням потреб проекту.